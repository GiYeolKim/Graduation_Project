import shutil
import subprocess
import os
from flask import Flask, render_template, request, jsonify, send_file
from flask_sse import sse

app = Flask(__name__)
app.config["REDIS_URL"] = "redis://localhost:6379"  # Replace with your Redis server URL
app.register_blueprint(sse, url_prefix='/stream')

file_path = ""


@app.route('/')
@app.route('/index')
def index():
    return render_template('index.html')


@app.route('/upload-video', methods=['POST'])
def upload_video():
    global file_path
    video_file = request.files['video']
    file_name = os.path.splitext(video_file.filename)[0]
    if not os.path.exists(file_name):
        os.makedirs(file_name)

    video_file.save(os.path.join(file_name, video_file.filename))
    print(request)

    file_path = os.path.abspath(file_name) + "/"
    output_path = training(file_path, video_file.filename)

    return send_file(output_path, mimetype='video/mp4', as_attachment=True)


def send_log(log):
    # Function to send log messages via Server-Sent Events (SSE)
    with app.app_context():
        sse.publish(log, type='log')


def run_subprocess(command):
    # Function to run subprocess command and capture output
    process = subprocess.Popen(
        command,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        universal_newlines=True
    )
    for line in iter(process.stdout.readline, ''):
        send_log(line.strip())
    process.stdout.close()
    process.wait()


def training(path, name):
    # Function to perform training based on the uploaded video
    subprocess.call(["python", "scripts/colmap2nerf.py", "--video_in", path + name,
                    "--video_fps", "2", "--aabb_scale", "16", "--overwrite"])

    subprocess.call(["python", "scripts/colmap2nerf.py", "--colmap_matcher", "exhaustive", "--run_colmap",
                    "--aabb_scale", "16", "--overwrite", "--images",
                    path + "images", "--out",
                    path + "/transforms.json", "--colmap_db", path + "colmap.db",
                    "--text", path + "colmap_text"])

    scene_path = path
    if not os.path.isdir(scene_path):
        raise NotADirectoryError(scene_path)

    shutil.copy('base_cam.json', path)

    train_steps = 2000
    snapshot_path = os.path.join(scene_path, f"{train_steps}.ingp")

    subprocess.call(["python", "scripts/run.py", scene_path, "--n_steps", str(train_steps),
                     "--save_snapshot", snapshot_path])

    video_camera_path = os.path.join(scene_path, "base_cam.json")
    if not os.path.isfile(video_camera_path):
        raise FileNotFoundError(video_camera_path)

    video_n_seconds = 2
    video_fps = 25
    width = 1920
    height = 1080
    output_video_path = os.path.join(scene_path, "output_video.mp4")

    subprocess.call(["python", "scripts/run.py", snapshot_path,
                     "--video_camera_path", video_camera_path,
                     "--video_n_seconds", str(video_n_seconds),
                     "--video_fps", str(video_fps),
                     "--width", str(width),
                     "--height", str(height),
                     "--video_output", output_video_path,
                     "--n_step", str(train_steps)
                     ])
    print(f"Generated video saved to:\n{output_video_path}")

    return output_video_path


@app.route('/get-dummy-text', methods=['GET'])
def get_dummy_text():
    # Generate dummy text
    dummy_text = "This is a dummy text generated by the server."

    # Return the dummy text as JSON response
    return jsonify(dummy_text=dummy_text)


@app.route('/get-video', methods=['GET'])
def get_video():
    video_path = 'IMG_1803/output_video.mp4'
    return send_file(video_path, as_attachment=True)


if __name__ == "__main__":
    app.run(debug=True)
